<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pytia_bounding_box.app.helper API documentation</title>
<meta name="description" content="Helper functions and classes for the UI." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pytia_bounding_box.app.helper</code></h1>
</header>
<section id="section-intro">
<p>Helper functions and classes for the UI.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
    Helper functions and classes for the UI.
&#34;&#34;&#34;

import functools
import os
import re
import time
import webbrowser
from pathlib import Path
from tkinter import BooleanVar
from tkinter import IntVar
from tkinter import messagebox as tkmsg
from typing import Optional
from typing import Tuple

from const import LOGON
from const import STYLES
from const import Axes
from const import Preference
from pytia.exceptions import PytiaDifferentDocumentError
from pytia.exceptions import PytiaDocumentNotSavedError
from pytia.exceptions import PytiaPropertyNotFoundError
from pytia.exceptions import PytiaValueError
from pytia.log import log
from resources import Preset
from resources import resource
from ttkbootstrap import Menu
from ttkbootstrap import Style


def show_help() -&gt; None:
    &#34;&#34;&#34;Opens the help docs.&#34;&#34;&#34;
    if url := resource.settings.urls.help:
        webbrowser.open_new(url)
    else:
        tkmsg.showinfo(
            title=resource.settings.title,
            message=&#34;Your administrator did not provide a help page for this app.&#34;,
        )


def get_offset(
    x: str | int | float,
    y: str | int | float,
    z: str | int | float,
    selected_preset: Preset,
    selected_axis: Axes,
    selected_offset: IntVar,
    selected_step: IntVar,
) -&gt; Tuple[float, float, float]:
    &#34;&#34;&#34;
    Returns the calculated offsets as tuple, representing the three axes X, Y &amp; Z.
    Calculates the offset values accordingly to the presets.json files.

    Args:
        x (str | int | float): The exact x measurements.
        y (str | int | float): The exact y measurements.
        z (str | int | float): The exact z measurements.
        selected_preset (Preset): The selected preset from the UI.
        selected_axis (Axes): The selected axis from the UI as Axes enum.
        selected_offset (IntVar): The selected offset from the UI.
        selected_step (IntVar): The selected step from the UI.

    Raises:
        PytiaValueError: Raised when the values cannot be casted to float.

    Returns:
        Tuple[float, float, float]: The offset values of the three axes X, Y &amp; Z.
    &#34;&#34;&#34;

    def _calculate_offset(value: float) -&gt; float:
        offset = float(selected_offset.get())
        step = float(selected_step.get())
        return (
            round((value + offset + ((step / 2) - 0.01)) / step, 0) * step
            if step &gt; 0
            else value
        )

    try:
        values = [float(x), float(y), float(z)]
    except ValueError as e:
        raise PytiaValueError(f&#34;Value error: {e}&#34;) from e

    enable = [False] * 3
    offsets = [0.0] * 3

    for i, axis in enumerate(Axes):
        if selected_preset.preference:
            enable[i] = (
                selected_preset.offset_preference
                if selected_axis.value == axis.value
                else selected_preset.offset_non_preference
            )
        else:
            enable[i] = bool(selected_preset.offset)
        offsets[i] = _calculate_offset(values[i]) if enable[i] else values[i]

    return offsets[0], offsets[1], offsets[2]


def get_preferred_axis(
    x: str | int | float,
    y: str | int | float,
    z: str | int | float,
    selected_preset: Preset,
) -&gt; Axes:
    &#34;&#34;&#34;
    Returns the preferred axis according to the settings files. If no match between the selected
    preset and the configuration can be found, the x axis will be returned.

    Args:
        x (str | int | float): The exact X measurements.
        y (str | int | float): The exact Y measurements.
        z (str | int | float): The exact Z measurements.
        selected_preset (Preset): The selected preset from the UI.

    Raises:
        PytiaValueError: Raised when the values cannot be casted to float.

    Returns:
        str: The preferred axis according to the preset.
    &#34;&#34;&#34;
    try:
        values = {Axes.X: float(x), Axes.Y: float(y), Axes.Z: float(z)}
    except Exception as e:
        raise PytiaValueError(f&#34;Cannot get preferred axis: {e}&#34;) from e

    match selected_preset.preference:
        case Preference.MIN.value:
            return min(values, key=values.get)  # type: ignore
        case Preference.MAX.value:
            return max(values, key=values.get)  # type: ignore
        case Preference.AXIS.value:
            # To get the turning axis we assume that at least two axes have the same value.
            # The turning axis is therefor the one axis that has a different value.
            # If all 3 axes have different values (imagine a hexagonal head screw), we assume
            # that the axis with the longest value is the turning axis.
            diff = {
                k: v for k, v in values.items() if list(values.values()).count(v) == 1
            }
            return (
                list(diff.keys())[0]
                if len(diff) == 1
                else max(values, key=values.get)  # type: ignore
            )

        case _:
            return Axes.X


def sort_base_size(
    x: str | int | float,
    y: str | int | float,
    z: str | int | float,
    selected_preset: Preset,
    selected_axis: Axes,
    thickness: BooleanVar,
) -&gt; str:
    &#34;&#34;&#34;
    Sorts and formats the base size according to the settings files.

    Args:
        x (str | int | float): The evaluated bounding value for the X axis.
        y (str | int | float): The evaluated bounding value for the Y axis.
        z (str | int | float): The evaluated bounding value for the Z axis.
        selected_preset (Preset): The selected preset from the UI.
        selected_axis (Axes): The selected axis from the UI as Axes enum.
        thickness (BooleanVar): The selection from the thickness checkbox.

    Returns:
        str: The sorted and formatted base size. Returns an empty string if the \
            numbers can&#39;t be sorted.
    &#34;&#34;&#34;

    try:
        x = float(x)
        y = float(y)
        z = float(z)
    except ValueError:
        return &#34;&#34;

    # The next three lines are to remove all positions after a comma if
    # the number only has zeros after the floating point.
    x = int(x) if x.is_integer() else x  # type: ignore
    y = int(y) if y.is_integer() else y  # type: ignore
    z = int(z) if z.is_integer() else z  # type: ignore

    axis_values = {Axes.X.value: x, Axes.Y.value: y, Axes.Z.value: z}

    if selected_preset.coord in [3, 4]:
        # Sort values based on config file settings (selections.json).
        sorted_axes = {
            k: str(v)
            for k, v in sorted(
                axis_values.items(),
                key=lambda item: item[1],
                reverse=selected_preset.sort_max_to_min,
            )
        }

        # Add postfix.
        if selected_preset.preference_postfix:
            sorted_axes[selected_axis.value] = (
                sorted_axes[selected_axis.value] + selected_preset.preference_postfix
            )

        # Write the preferred axis at last.
        if selected_preset.preference:
            preferred_value = sorted_axes[selected_axis.value]
            del sorted_axes[selected_axis.value]
            sorted_list = list(sorted_axes.values())

            # Retrieve the thickness (if available) and write it at third position.
            if thickness.get() and selected_preset.coord == 4:
                part_helper = LazyPartHelper()
                thickness_value = part_helper.get_parameter(
                    resource.settings.parameters.thickness
                )
                if thickness_value:
                    try:
                        thickness_value = float(thickness_value)
                        if thickness_value &gt; 0:
                            thickness_value = (
                                int(thickness_value)
                                if thickness_value.is_integer()  # type: ignore
                                else thickness_value
                            )
                            sorted_list.append(str(thickness_value))
                    except ValueError:
                        log.warning(&#34;Parameter &#39;thickness&#39; cannot be casted to float.&#34;)

            # Add the length at last.
            sorted_list.append(preferred_value)
        else:
            sorted_list = list(sorted_axes.values())
        return &#34; x &#34;.join(sorted_list)
    else:
        length = axis_values[selected_axis.value]
        del axis_values[selected_axis.value]
        diameter = max(axis_values.values())
        return f&#34;Ø{diameter} x {length}&#34;


def set_appearance_menu(appearance_menu: Menu) -&gt; None:
    &#34;&#34;&#34;Binds all callbacks to the appearance menubar.&#34;&#34;&#34;
    for index, _ in enumerate(STYLES):
        appearance_menu.entryconfig(index, command=lambda x=index: change_theme(x))


def change_theme(index: int) -&gt; None:
    &#34;&#34;&#34;Changes the apps theme.

    Args:
        index (int): The index of the theme from the STYLES list.
    &#34;&#34;&#34;
    theme_name = STYLES[index]
    Style(theme=theme_name)
    resource.appdata.theme = theme_name
    log.info(f&#34;Changed theme to {theme_name} ({index}).&#34;)


class LazyPartHelper:
    &#34;&#34;&#34;
    Helper class for late imports of any kind of methods related to handle part operations.

    Important: This class loads the current part document only once (on instantiation). If the
    document changes all operations will be made on the original document.

    Use the ensure_part_not_changed method if you&#39;re not sure if the part hasn&#39;t changed.
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        # Import the PyPartDocument after the GUI exception handler is initialized.
        # Otherwise the CATIA-not-running-exception will not be caught.
        # Also: The UI will load a little bit faster.

        # pylint: disable=C0415
        # pylint: disable=C0103
        t0 = time.perf_counter()
        from pytia.framework import framework
        from pytia.wrapper.documents.part_documents import PyPartDocument

        t1 = time.perf_counter()
        log.debug(f&#34;Loaded PyPartDocument in {(t1-t0):.4f}s&#34;)
        # pylint: enable=C0415
        # pylint: enable=C0103

        self.framework = framework
        self.part_document = PyPartDocument(strict_naming=False)
        self.part_document.current()
        self.part_document.product.part_number = self.part_document.document.name.split(
            &#34;.CATP&#34;
        )[0]
        self.part_name = self.part_document.document.name

        # FIXME: Locking CATIA prevents the ability to detect changes on the document.
        # This means that the part or product won&#39;t be saved, even if the user tries to manually
        # save it.
        # self._lock_catia(True)
        # atexit.register(lambda: self._lock_catia(False))

        if not resource.settings.restrictions.allow_unsaved and not os.path.isabs(
            self.part_document.document.full_name
        ):
            raise PytiaDocumentNotSavedError(
                &#34;It is not allowed to edit the parameters of an unsaved document. &#34;
                &#34;Please save the document first.&#34;
            )

    @property
    def path(self) -&gt; Path:
        &#34;&#34;&#34;Returns the path of the document.&#34;&#34;&#34;
        return Path(self.part_document.document.full_name)

    def _lock_catia(self, value: bool) -&gt; None:
        log.debug(f&#34;Setting catia lock to {value!r}&#34;)
        self.framework.catia.refresh_display = not value
        self.framework.catia.interactive = not value
        self.framework.catia.display_file_alerts = value
        self.framework.catia.undo_redo_lock = value
        if value:
            self.framework.catia.disable_new_undo_redo_transaction()
        else:
            self.framework.catia.enable_new_undo_redo_transaction()

    def _part_changed(self) -&gt; bool:
        &#34;&#34;&#34;Returns True if the current part document has changed, False if not.&#34;&#34;&#34;
        part_document = self.part_document
        part_document.current()
        return part_document.document.name != self.part_name

    @staticmethod
    def _ensure_part_not_changed(func):
        &#34;&#34;&#34;
        Ensures that the part hasn&#39;t changed.
        Raises the PytiaDifferentDocumentError if the part has changed.
        &#34;&#34;&#34;

        # pylint: disable=W0212
        @functools.wraps(func)
        def _ensure_part_not_changed_wrapper(self, *args, **kwargs):
            if self._part_changed():
                part_document = self.part_document
                part_document.current()
                raise PytiaDifferentDocumentError(
                    f&#34;The name of the current document has changed:\n&#34;
                    f&#34; - Original was {self.part_name}\n&#34;
                    f&#34; - Current is {part_document.document.name}&#34;
                )
            return func(self, *args, **kwargs)

        # pylint: enable=W0212

        return _ensure_part_not_changed_wrapper

    @_ensure_part_not_changed
    def get_parameter(self, name: str) -&gt; Optional[str]:
        &#34;&#34;&#34;
        Retrieves a parameters value from the part.

        Args:
            name (str): The name of the parameter to retrieve the value from.

        Returns:
            Optional[str]: The value of the parameter as string.
        &#34;&#34;&#34;
        try:
            if self.part_document.parameters.exists(name):
                param = str(self.part_document.parameters.get(name).value)
                log.info(f&#34;Retrieved parameter {name} ({param}) from part.&#34;)
                return param

            log.info(f&#34;Couldn&#39;t retrieve parameter {name} from part: Doesn&#39;t exists.&#34;)
        except AttributeError as e:
            log.exception(f&#34;Couldn&#39;t retrieve parameter {name} from part: {e}&#34;)

        return None

    @_ensure_part_not_changed
    def get_property(self, name: str) -&gt; Optional[str]:
        &#34;&#34;&#34;
        Retrieves a properties value from the part properties.

        Args:
            name (str): The name of the property to retrieve the value from.

        Returns:
            Optional[str]: The value of the property as string.
        &#34;&#34;&#34;
        if self.part_document.properties.exists(name):
            param = str(self.part_document.properties.get_by_name(name).value)
            log.info(f&#34;Retrieved property {name} ({param}) from part.&#34;)
            return param

        log.info(f&#34;Couldn&#39;t retrieve property {name} from part: Doesn&#39;t exists.&#34;)
        return None

    @_ensure_part_not_changed
    def write_property(self, name: str, value: str) -&gt; None:
        &#34;&#34;&#34;
        Writes the property to the part properties.

        Args:
            name (str): The name of the property.
            value (str): The value of the property.
        &#34;&#34;&#34;
        if not self.part_document.properties.exists(name):
            if not resource.settings.restrictions.allow_property_creation:
                raise PytiaPropertyNotFoundError(
                    &#34;The app doesn&#39;t have the permission to create properties at runtime. &#34;
                    &#34;All required properties must be created before running this app.&#34;
                )
            self.part_document.properties.create(name, value)
        self.part_document.properties.set_value(name, value)
        log.info(f&#34;Wrote property {name!r} to part with value {value!r}.&#34;)

    @_ensure_part_not_changed
    def write_modifier(self, write_creator: bool = True) -&gt; None:
        &#34;&#34;&#34;
        Saves the modifier to the part properties.

        Args:
            write_creator (bool, optional): Also write the creator. Defaults to True.
        &#34;&#34;&#34;
        if resource.user_exists(LOGON):
            user = resource.get_user_by_logon(LOGON)
            filter_result = re.findall(r&#34;\%(.*?)\%&#34;, resource.settings.save_modifier_by)
            modifier = resource.settings.save_modifier_by

            if all(elem in user.keys for elem in filter_result):
                for key in filter_result:
                    modifier = modifier.replace(f&#34;%{key}%&#34;, getattr(user, key))
            else:
                log.warning(
                    f&#34;Cannot save user by {resource.settings.save_modifier_by!r}. &#34;
                    f&#34;Saving logon name {LOGON!r} to {resource.props.modifier!r}.&#34;
                )
                modifier = LOGON
        else:
            modifier = LOGON
            log.warning(
                f&#34;Current user doesn&#39;t exist in config file. Saving logon name {LOGON!r} to &#34;
                f&#34;{resource.props.modifier!r}.&#34;
            )

        self.write_property(resource.props.modifier, modifier)
        if not self.get_property(resource.props.creator) and write_creator:
            self.write_property(resource.props.creator, modifier)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pytia_bounding_box.app.helper.change_theme"><code class="name flex">
<span>def <span class="ident">change_theme</span></span>(<span>index: int) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Changes the apps theme.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code></dt>
<dd>The index of the theme from the STYLES list.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_theme(index: int) -&gt; None:
    &#34;&#34;&#34;Changes the apps theme.

    Args:
        index (int): The index of the theme from the STYLES list.
    &#34;&#34;&#34;
    theme_name = STYLES[index]
    Style(theme=theme_name)
    resource.appdata.theme = theme_name
    log.info(f&#34;Changed theme to {theme_name} ({index}).&#34;)</code></pre>
</details>
</dd>
<dt id="pytia_bounding_box.app.helper.get_offset"><code class="name flex">
<span>def <span class="ident">get_offset</span></span>(<span>x: str | int | float, y: str | int | float, z: str | int | float, selected_preset: resources.Preset, selected_axis: const.Axes, selected_offset: tkinter.IntVar, selected_step: tkinter.IntVar) ‑> Tuple[float, float, float]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the calculated offsets as tuple, representing the three axes X, Y &amp; Z.
Calculates the offset values accordingly to the presets.json files.</p>
<h2 id="args">Args</h2>
<dl>
<dt>x (str | int | float): The exact x measurements.</dt>
<dt>y (str | int | float): The exact y measurements.</dt>
<dt>z (str | int | float): The exact z measurements.</dt>
<dt><strong><code>selected_preset</code></strong> :&ensp;<code>Preset</code></dt>
<dd>The selected preset from the UI.</dd>
<dt><strong><code>selected_axis</code></strong> :&ensp;<code>Axes</code></dt>
<dd>The selected axis from the UI as Axes enum.</dd>
<dt><strong><code>selected_offset</code></strong> :&ensp;<code>IntVar</code></dt>
<dd>The selected offset from the UI.</dd>
<dt><strong><code>selected_step</code></strong> :&ensp;<code>IntVar</code></dt>
<dd>The selected step from the UI.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>PytiaValueError</code></dt>
<dd>Raised when the values cannot be casted to float.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[float, float, float]</code></dt>
<dd>The offset values of the three axes X, Y &amp; Z.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_offset(
    x: str | int | float,
    y: str | int | float,
    z: str | int | float,
    selected_preset: Preset,
    selected_axis: Axes,
    selected_offset: IntVar,
    selected_step: IntVar,
) -&gt; Tuple[float, float, float]:
    &#34;&#34;&#34;
    Returns the calculated offsets as tuple, representing the three axes X, Y &amp; Z.
    Calculates the offset values accordingly to the presets.json files.

    Args:
        x (str | int | float): The exact x measurements.
        y (str | int | float): The exact y measurements.
        z (str | int | float): The exact z measurements.
        selected_preset (Preset): The selected preset from the UI.
        selected_axis (Axes): The selected axis from the UI as Axes enum.
        selected_offset (IntVar): The selected offset from the UI.
        selected_step (IntVar): The selected step from the UI.

    Raises:
        PytiaValueError: Raised when the values cannot be casted to float.

    Returns:
        Tuple[float, float, float]: The offset values of the three axes X, Y &amp; Z.
    &#34;&#34;&#34;

    def _calculate_offset(value: float) -&gt; float:
        offset = float(selected_offset.get())
        step = float(selected_step.get())
        return (
            round((value + offset + ((step / 2) - 0.01)) / step, 0) * step
            if step &gt; 0
            else value
        )

    try:
        values = [float(x), float(y), float(z)]
    except ValueError as e:
        raise PytiaValueError(f&#34;Value error: {e}&#34;) from e

    enable = [False] * 3
    offsets = [0.0] * 3

    for i, axis in enumerate(Axes):
        if selected_preset.preference:
            enable[i] = (
                selected_preset.offset_preference
                if selected_axis.value == axis.value
                else selected_preset.offset_non_preference
            )
        else:
            enable[i] = bool(selected_preset.offset)
        offsets[i] = _calculate_offset(values[i]) if enable[i] else values[i]

    return offsets[0], offsets[1], offsets[2]</code></pre>
</details>
</dd>
<dt id="pytia_bounding_box.app.helper.get_preferred_axis"><code class="name flex">
<span>def <span class="ident">get_preferred_axis</span></span>(<span>x: str | int | float, y: str | int | float, z: str | int | float, selected_preset: resources.Preset) ‑> const.Axes</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the preferred axis according to the settings files. If no match between the selected
preset and the configuration can be found, the x axis will be returned.</p>
<h2 id="args">Args</h2>
<dl>
<dt>x (str | int | float): The exact X measurements.</dt>
<dt>y (str | int | float): The exact Y measurements.</dt>
<dt>z (str | int | float): The exact Z measurements.</dt>
<dt><strong><code>selected_preset</code></strong> :&ensp;<code>Preset</code></dt>
<dd>The selected preset from the UI.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>PytiaValueError</code></dt>
<dd>Raised when the values cannot be casted to float.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The preferred axis according to the preset.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_preferred_axis(
    x: str | int | float,
    y: str | int | float,
    z: str | int | float,
    selected_preset: Preset,
) -&gt; Axes:
    &#34;&#34;&#34;
    Returns the preferred axis according to the settings files. If no match between the selected
    preset and the configuration can be found, the x axis will be returned.

    Args:
        x (str | int | float): The exact X measurements.
        y (str | int | float): The exact Y measurements.
        z (str | int | float): The exact Z measurements.
        selected_preset (Preset): The selected preset from the UI.

    Raises:
        PytiaValueError: Raised when the values cannot be casted to float.

    Returns:
        str: The preferred axis according to the preset.
    &#34;&#34;&#34;
    try:
        values = {Axes.X: float(x), Axes.Y: float(y), Axes.Z: float(z)}
    except Exception as e:
        raise PytiaValueError(f&#34;Cannot get preferred axis: {e}&#34;) from e

    match selected_preset.preference:
        case Preference.MIN.value:
            return min(values, key=values.get)  # type: ignore
        case Preference.MAX.value:
            return max(values, key=values.get)  # type: ignore
        case Preference.AXIS.value:
            # To get the turning axis we assume that at least two axes have the same value.
            # The turning axis is therefor the one axis that has a different value.
            # If all 3 axes have different values (imagine a hexagonal head screw), we assume
            # that the axis with the longest value is the turning axis.
            diff = {
                k: v for k, v in values.items() if list(values.values()).count(v) == 1
            }
            return (
                list(diff.keys())[0]
                if len(diff) == 1
                else max(values, key=values.get)  # type: ignore
            )

        case _:
            return Axes.X</code></pre>
</details>
</dd>
<dt id="pytia_bounding_box.app.helper.set_appearance_menu"><code class="name flex">
<span>def <span class="ident">set_appearance_menu</span></span>(<span>appearance_menu: tkinter.Menu) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Binds all callbacks to the appearance menubar.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_appearance_menu(appearance_menu: Menu) -&gt; None:
    &#34;&#34;&#34;Binds all callbacks to the appearance menubar.&#34;&#34;&#34;
    for index, _ in enumerate(STYLES):
        appearance_menu.entryconfig(index, command=lambda x=index: change_theme(x))</code></pre>
</details>
</dd>
<dt id="pytia_bounding_box.app.helper.show_help"><code class="name flex">
<span>def <span class="ident">show_help</span></span>(<span>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Opens the help docs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_help() -&gt; None:
    &#34;&#34;&#34;Opens the help docs.&#34;&#34;&#34;
    if url := resource.settings.urls.help:
        webbrowser.open_new(url)
    else:
        tkmsg.showinfo(
            title=resource.settings.title,
            message=&#34;Your administrator did not provide a help page for this app.&#34;,
        )</code></pre>
</details>
</dd>
<dt id="pytia_bounding_box.app.helper.sort_base_size"><code class="name flex">
<span>def <span class="ident">sort_base_size</span></span>(<span>x: str | int | float, y: str | int | float, z: str | int | float, selected_preset: resources.Preset, selected_axis: const.Axes, thickness: tkinter.BooleanVar) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Sorts and formats the base size according to the settings files.</p>
<h2 id="args">Args</h2>
<dl>
<dt>x (str | int | float): The evaluated bounding value for the X axis.</dt>
<dt>y (str | int | float): The evaluated bounding value for the Y axis.</dt>
<dt>z (str | int | float): The evaluated bounding value for the Z axis.</dt>
<dt><strong><code>selected_preset</code></strong> :&ensp;<code>Preset</code></dt>
<dd>The selected preset from the UI.</dd>
<dt><strong><code>selected_axis</code></strong> :&ensp;<code>Axes</code></dt>
<dd>The selected axis from the UI as Axes enum.</dd>
<dt><strong><code>thickness</code></strong> :&ensp;<code>BooleanVar</code></dt>
<dd>The selection from the thickness checkbox.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The sorted and formatted base size. Returns an empty string if the
numbers can't be sorted.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort_base_size(
    x: str | int | float,
    y: str | int | float,
    z: str | int | float,
    selected_preset: Preset,
    selected_axis: Axes,
    thickness: BooleanVar,
) -&gt; str:
    &#34;&#34;&#34;
    Sorts and formats the base size according to the settings files.

    Args:
        x (str | int | float): The evaluated bounding value for the X axis.
        y (str | int | float): The evaluated bounding value for the Y axis.
        z (str | int | float): The evaluated bounding value for the Z axis.
        selected_preset (Preset): The selected preset from the UI.
        selected_axis (Axes): The selected axis from the UI as Axes enum.
        thickness (BooleanVar): The selection from the thickness checkbox.

    Returns:
        str: The sorted and formatted base size. Returns an empty string if the \
            numbers can&#39;t be sorted.
    &#34;&#34;&#34;

    try:
        x = float(x)
        y = float(y)
        z = float(z)
    except ValueError:
        return &#34;&#34;

    # The next three lines are to remove all positions after a comma if
    # the number only has zeros after the floating point.
    x = int(x) if x.is_integer() else x  # type: ignore
    y = int(y) if y.is_integer() else y  # type: ignore
    z = int(z) if z.is_integer() else z  # type: ignore

    axis_values = {Axes.X.value: x, Axes.Y.value: y, Axes.Z.value: z}

    if selected_preset.coord in [3, 4]:
        # Sort values based on config file settings (selections.json).
        sorted_axes = {
            k: str(v)
            for k, v in sorted(
                axis_values.items(),
                key=lambda item: item[1],
                reverse=selected_preset.sort_max_to_min,
            )
        }

        # Add postfix.
        if selected_preset.preference_postfix:
            sorted_axes[selected_axis.value] = (
                sorted_axes[selected_axis.value] + selected_preset.preference_postfix
            )

        # Write the preferred axis at last.
        if selected_preset.preference:
            preferred_value = sorted_axes[selected_axis.value]
            del sorted_axes[selected_axis.value]
            sorted_list = list(sorted_axes.values())

            # Retrieve the thickness (if available) and write it at third position.
            if thickness.get() and selected_preset.coord == 4:
                part_helper = LazyPartHelper()
                thickness_value = part_helper.get_parameter(
                    resource.settings.parameters.thickness
                )
                if thickness_value:
                    try:
                        thickness_value = float(thickness_value)
                        if thickness_value &gt; 0:
                            thickness_value = (
                                int(thickness_value)
                                if thickness_value.is_integer()  # type: ignore
                                else thickness_value
                            )
                            sorted_list.append(str(thickness_value))
                    except ValueError:
                        log.warning(&#34;Parameter &#39;thickness&#39; cannot be casted to float.&#34;)

            # Add the length at last.
            sorted_list.append(preferred_value)
        else:
            sorted_list = list(sorted_axes.values())
        return &#34; x &#34;.join(sorted_list)
    else:
        length = axis_values[selected_axis.value]
        del axis_values[selected_axis.value]
        diameter = max(axis_values.values())
        return f&#34;Ø{diameter} x {length}&#34;</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pytia_bounding_box.app.helper.LazyPartHelper"><code class="flex name class">
<span>class <span class="ident">LazyPartHelper</span></span>
</code></dt>
<dd>
<div class="desc"><p>Helper class for late imports of any kind of methods related to handle part operations.</p>
<p>Important: This class loads the current part document only once (on instantiation). If the
document changes all operations will be made on the original document.</p>
<p>Use the ensure_part_not_changed method if you're not sure if the part hasn't changed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LazyPartHelper:
    &#34;&#34;&#34;
    Helper class for late imports of any kind of methods related to handle part operations.

    Important: This class loads the current part document only once (on instantiation). If the
    document changes all operations will be made on the original document.

    Use the ensure_part_not_changed method if you&#39;re not sure if the part hasn&#39;t changed.
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        # Import the PyPartDocument after the GUI exception handler is initialized.
        # Otherwise the CATIA-not-running-exception will not be caught.
        # Also: The UI will load a little bit faster.

        # pylint: disable=C0415
        # pylint: disable=C0103
        t0 = time.perf_counter()
        from pytia.framework import framework
        from pytia.wrapper.documents.part_documents import PyPartDocument

        t1 = time.perf_counter()
        log.debug(f&#34;Loaded PyPartDocument in {(t1-t0):.4f}s&#34;)
        # pylint: enable=C0415
        # pylint: enable=C0103

        self.framework = framework
        self.part_document = PyPartDocument(strict_naming=False)
        self.part_document.current()
        self.part_document.product.part_number = self.part_document.document.name.split(
            &#34;.CATP&#34;
        )[0]
        self.part_name = self.part_document.document.name

        # FIXME: Locking CATIA prevents the ability to detect changes on the document.
        # This means that the part or product won&#39;t be saved, even if the user tries to manually
        # save it.
        # self._lock_catia(True)
        # atexit.register(lambda: self._lock_catia(False))

        if not resource.settings.restrictions.allow_unsaved and not os.path.isabs(
            self.part_document.document.full_name
        ):
            raise PytiaDocumentNotSavedError(
                &#34;It is not allowed to edit the parameters of an unsaved document. &#34;
                &#34;Please save the document first.&#34;
            )

    @property
    def path(self) -&gt; Path:
        &#34;&#34;&#34;Returns the path of the document.&#34;&#34;&#34;
        return Path(self.part_document.document.full_name)

    def _lock_catia(self, value: bool) -&gt; None:
        log.debug(f&#34;Setting catia lock to {value!r}&#34;)
        self.framework.catia.refresh_display = not value
        self.framework.catia.interactive = not value
        self.framework.catia.display_file_alerts = value
        self.framework.catia.undo_redo_lock = value
        if value:
            self.framework.catia.disable_new_undo_redo_transaction()
        else:
            self.framework.catia.enable_new_undo_redo_transaction()

    def _part_changed(self) -&gt; bool:
        &#34;&#34;&#34;Returns True if the current part document has changed, False if not.&#34;&#34;&#34;
        part_document = self.part_document
        part_document.current()
        return part_document.document.name != self.part_name

    @staticmethod
    def _ensure_part_not_changed(func):
        &#34;&#34;&#34;
        Ensures that the part hasn&#39;t changed.
        Raises the PytiaDifferentDocumentError if the part has changed.
        &#34;&#34;&#34;

        # pylint: disable=W0212
        @functools.wraps(func)
        def _ensure_part_not_changed_wrapper(self, *args, **kwargs):
            if self._part_changed():
                part_document = self.part_document
                part_document.current()
                raise PytiaDifferentDocumentError(
                    f&#34;The name of the current document has changed:\n&#34;
                    f&#34; - Original was {self.part_name}\n&#34;
                    f&#34; - Current is {part_document.document.name}&#34;
                )
            return func(self, *args, **kwargs)

        # pylint: enable=W0212

        return _ensure_part_not_changed_wrapper

    @_ensure_part_not_changed
    def get_parameter(self, name: str) -&gt; Optional[str]:
        &#34;&#34;&#34;
        Retrieves a parameters value from the part.

        Args:
            name (str): The name of the parameter to retrieve the value from.

        Returns:
            Optional[str]: The value of the parameter as string.
        &#34;&#34;&#34;
        try:
            if self.part_document.parameters.exists(name):
                param = str(self.part_document.parameters.get(name).value)
                log.info(f&#34;Retrieved parameter {name} ({param}) from part.&#34;)
                return param

            log.info(f&#34;Couldn&#39;t retrieve parameter {name} from part: Doesn&#39;t exists.&#34;)
        except AttributeError as e:
            log.exception(f&#34;Couldn&#39;t retrieve parameter {name} from part: {e}&#34;)

        return None

    @_ensure_part_not_changed
    def get_property(self, name: str) -&gt; Optional[str]:
        &#34;&#34;&#34;
        Retrieves a properties value from the part properties.

        Args:
            name (str): The name of the property to retrieve the value from.

        Returns:
            Optional[str]: The value of the property as string.
        &#34;&#34;&#34;
        if self.part_document.properties.exists(name):
            param = str(self.part_document.properties.get_by_name(name).value)
            log.info(f&#34;Retrieved property {name} ({param}) from part.&#34;)
            return param

        log.info(f&#34;Couldn&#39;t retrieve property {name} from part: Doesn&#39;t exists.&#34;)
        return None

    @_ensure_part_not_changed
    def write_property(self, name: str, value: str) -&gt; None:
        &#34;&#34;&#34;
        Writes the property to the part properties.

        Args:
            name (str): The name of the property.
            value (str): The value of the property.
        &#34;&#34;&#34;
        if not self.part_document.properties.exists(name):
            if not resource.settings.restrictions.allow_property_creation:
                raise PytiaPropertyNotFoundError(
                    &#34;The app doesn&#39;t have the permission to create properties at runtime. &#34;
                    &#34;All required properties must be created before running this app.&#34;
                )
            self.part_document.properties.create(name, value)
        self.part_document.properties.set_value(name, value)
        log.info(f&#34;Wrote property {name!r} to part with value {value!r}.&#34;)

    @_ensure_part_not_changed
    def write_modifier(self, write_creator: bool = True) -&gt; None:
        &#34;&#34;&#34;
        Saves the modifier to the part properties.

        Args:
            write_creator (bool, optional): Also write the creator. Defaults to True.
        &#34;&#34;&#34;
        if resource.user_exists(LOGON):
            user = resource.get_user_by_logon(LOGON)
            filter_result = re.findall(r&#34;\%(.*?)\%&#34;, resource.settings.save_modifier_by)
            modifier = resource.settings.save_modifier_by

            if all(elem in user.keys for elem in filter_result):
                for key in filter_result:
                    modifier = modifier.replace(f&#34;%{key}%&#34;, getattr(user, key))
            else:
                log.warning(
                    f&#34;Cannot save user by {resource.settings.save_modifier_by!r}. &#34;
                    f&#34;Saving logon name {LOGON!r} to {resource.props.modifier!r}.&#34;
                )
                modifier = LOGON
        else:
            modifier = LOGON
            log.warning(
                f&#34;Current user doesn&#39;t exist in config file. Saving logon name {LOGON!r} to &#34;
                f&#34;{resource.props.modifier!r}.&#34;
            )

        self.write_property(resource.props.modifier, modifier)
        if not self.get_property(resource.props.creator) and write_creator:
            self.write_property(resource.props.creator, modifier)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pytia_bounding_box.app.helper.LazyPartHelper.path"><code class="name">var <span class="ident">path</span> : pathlib.Path</code></dt>
<dd>
<div class="desc"><p>Returns the path of the document.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def path(self) -&gt; Path:
    &#34;&#34;&#34;Returns the path of the document.&#34;&#34;&#34;
    return Path(self.part_document.document.full_name)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pytia_bounding_box.app.helper.LazyPartHelper.get_parameter"><code class="name flex">
<span>def <span class="ident">get_parameter</span></span>(<span>self, name: str) ‑> Optional[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves a parameters value from the part.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the parameter to retrieve the value from.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[str]</code></dt>
<dd>The value of the parameter as string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_ensure_part_not_changed
def get_parameter(self, name: str) -&gt; Optional[str]:
    &#34;&#34;&#34;
    Retrieves a parameters value from the part.

    Args:
        name (str): The name of the parameter to retrieve the value from.

    Returns:
        Optional[str]: The value of the parameter as string.
    &#34;&#34;&#34;
    try:
        if self.part_document.parameters.exists(name):
            param = str(self.part_document.parameters.get(name).value)
            log.info(f&#34;Retrieved parameter {name} ({param}) from part.&#34;)
            return param

        log.info(f&#34;Couldn&#39;t retrieve parameter {name} from part: Doesn&#39;t exists.&#34;)
    except AttributeError as e:
        log.exception(f&#34;Couldn&#39;t retrieve parameter {name} from part: {e}&#34;)

    return None</code></pre>
</details>
</dd>
<dt id="pytia_bounding_box.app.helper.LazyPartHelper.get_property"><code class="name flex">
<span>def <span class="ident">get_property</span></span>(<span>self, name: str) ‑> Optional[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves a properties value from the part properties.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the property to retrieve the value from.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[str]</code></dt>
<dd>The value of the property as string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_ensure_part_not_changed
def get_property(self, name: str) -&gt; Optional[str]:
    &#34;&#34;&#34;
    Retrieves a properties value from the part properties.

    Args:
        name (str): The name of the property to retrieve the value from.

    Returns:
        Optional[str]: The value of the property as string.
    &#34;&#34;&#34;
    if self.part_document.properties.exists(name):
        param = str(self.part_document.properties.get_by_name(name).value)
        log.info(f&#34;Retrieved property {name} ({param}) from part.&#34;)
        return param

    log.info(f&#34;Couldn&#39;t retrieve property {name} from part: Doesn&#39;t exists.&#34;)
    return None</code></pre>
</details>
</dd>
<dt id="pytia_bounding_box.app.helper.LazyPartHelper.write_modifier"><code class="name flex">
<span>def <span class="ident">write_modifier</span></span>(<span>self, write_creator: bool = True) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the modifier to the part properties.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>write_creator</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Also write the creator. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_ensure_part_not_changed
def write_modifier(self, write_creator: bool = True) -&gt; None:
    &#34;&#34;&#34;
    Saves the modifier to the part properties.

    Args:
        write_creator (bool, optional): Also write the creator. Defaults to True.
    &#34;&#34;&#34;
    if resource.user_exists(LOGON):
        user = resource.get_user_by_logon(LOGON)
        filter_result = re.findall(r&#34;\%(.*?)\%&#34;, resource.settings.save_modifier_by)
        modifier = resource.settings.save_modifier_by

        if all(elem in user.keys for elem in filter_result):
            for key in filter_result:
                modifier = modifier.replace(f&#34;%{key}%&#34;, getattr(user, key))
        else:
            log.warning(
                f&#34;Cannot save user by {resource.settings.save_modifier_by!r}. &#34;
                f&#34;Saving logon name {LOGON!r} to {resource.props.modifier!r}.&#34;
            )
            modifier = LOGON
    else:
        modifier = LOGON
        log.warning(
            f&#34;Current user doesn&#39;t exist in config file. Saving logon name {LOGON!r} to &#34;
            f&#34;{resource.props.modifier!r}.&#34;
        )

    self.write_property(resource.props.modifier, modifier)
    if not self.get_property(resource.props.creator) and write_creator:
        self.write_property(resource.props.creator, modifier)</code></pre>
</details>
</dd>
<dt id="pytia_bounding_box.app.helper.LazyPartHelper.write_property"><code class="name flex">
<span>def <span class="ident">write_property</span></span>(<span>self, name: str, value: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Writes the property to the part properties.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the property.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>str</code></dt>
<dd>The value of the property.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_ensure_part_not_changed
def write_property(self, name: str, value: str) -&gt; None:
    &#34;&#34;&#34;
    Writes the property to the part properties.

    Args:
        name (str): The name of the property.
        value (str): The value of the property.
    &#34;&#34;&#34;
    if not self.part_document.properties.exists(name):
        if not resource.settings.restrictions.allow_property_creation:
            raise PytiaPropertyNotFoundError(
                &#34;The app doesn&#39;t have the permission to create properties at runtime. &#34;
                &#34;All required properties must be created before running this app.&#34;
            )
        self.part_document.properties.create(name, value)
    self.part_document.properties.set_value(name, value)
    log.info(f&#34;Wrote property {name!r} to part with value {value!r}.&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pytia_bounding_box.app" href="index.html">pytia_bounding_box.app</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="pytia_bounding_box.app.helper.change_theme" href="#pytia_bounding_box.app.helper.change_theme">change_theme</a></code></li>
<li><code><a title="pytia_bounding_box.app.helper.get_offset" href="#pytia_bounding_box.app.helper.get_offset">get_offset</a></code></li>
<li><code><a title="pytia_bounding_box.app.helper.get_preferred_axis" href="#pytia_bounding_box.app.helper.get_preferred_axis">get_preferred_axis</a></code></li>
<li><code><a title="pytia_bounding_box.app.helper.set_appearance_menu" href="#pytia_bounding_box.app.helper.set_appearance_menu">set_appearance_menu</a></code></li>
<li><code><a title="pytia_bounding_box.app.helper.show_help" href="#pytia_bounding_box.app.helper.show_help">show_help</a></code></li>
<li><code><a title="pytia_bounding_box.app.helper.sort_base_size" href="#pytia_bounding_box.app.helper.sort_base_size">sort_base_size</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pytia_bounding_box.app.helper.LazyPartHelper" href="#pytia_bounding_box.app.helper.LazyPartHelper">LazyPartHelper</a></code></h4>
<ul class="">
<li><code><a title="pytia_bounding_box.app.helper.LazyPartHelper.get_parameter" href="#pytia_bounding_box.app.helper.LazyPartHelper.get_parameter">get_parameter</a></code></li>
<li><code><a title="pytia_bounding_box.app.helper.LazyPartHelper.get_property" href="#pytia_bounding_box.app.helper.LazyPartHelper.get_property">get_property</a></code></li>
<li><code><a title="pytia_bounding_box.app.helper.LazyPartHelper.path" href="#pytia_bounding_box.app.helper.LazyPartHelper.path">path</a></code></li>
<li><code><a title="pytia_bounding_box.app.helper.LazyPartHelper.write_modifier" href="#pytia_bounding_box.app.helper.LazyPartHelper.write_modifier">write_modifier</a></code></li>
<li><code><a title="pytia_bounding_box.app.helper.LazyPartHelper.write_property" href="#pytia_bounding_box.app.helper.LazyPartHelper.write_property">write_property</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>